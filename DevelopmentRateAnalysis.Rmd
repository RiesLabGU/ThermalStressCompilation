---
title: "Development rate"
output: html_notebook
---
## Steps
1. Import data
2. Select sets with at least 4 data points and a complete curve (low, peak, high) for egg, larva, pupa, eggtoadult.
3. Obtain predicted dr in the range from 0 to 40 C using linear interpolation
4. Calculate Ropt (rate at Topt) and minTopt, maxTopt
5. Calculate interval (min, max, length)
6. Plot
7. Perform analyses

```{r}
# load packages
library(tidyverse)
library(readxl)
library(cowplot)
```

 Import data
```{r}
# Mariana's desktop
Data <- read_xlsx("/Users/marianaabarcazama/Desktop/Projects/ThermalPerformance/PhysiologyDatabaseVersion5.xlsx", 
                  sheet = "WorkingTable", na = c("NA", ""))
```

```{r}
# Mariana's laptop
Data <- read_xlsx("/Users/mar/Desktop/Projects/ThermalPerformance/PhysiologyDatabaseVersion5.xlsx", 
                  sheet = "WorkingTable", na = c("NA", "")) 

```


```{r}
# Discard parasitoids and change character to factor 
unique(Data$status)
Ana <- Data[Data$status != "parasitoid",]
rm(Data)

# convert character to factor
Ana <- Ana %>%
  mutate_if(is.character, factor)
```

# 2. Select sets 
To be included in development rate analyses, sets should have at least 4 temperature treatments reporting development time that form a complete curve (low 50%, peak, high 50%) for egg, larva, pupa or eggtoadult.


```{r}
# Function to determine whether a set is:
# "Complete" (has low, peak and high values)
# "Incomplete" (only low and peak)
# "No data" (no development rate data available)
Ana$set2 <- Ana$set
is_complete <- function(dat){
  dat <- dat[!is.na(dat$dr) & !is.na(dat$temp),] # Remove treatments with no dr data
 if(nrow(dat) > 3 ){
  
   y_max <- max(dat$dr, na.rm = T) # get maximum value for dr
  x_max <- dat[dat$dr == y_max, "temp"][[1]][1]# get temperature that maximizes dr 
  
  species <- unique(dat$sp)
  lifestage <- unique(dat$lifestage)
  seti <- unique(dat$set2)
  print(paste("set:",seti))
  print(species)
  print(lifestage)
  print(x_max)
  print(y_max)
  cold <- filter(dat, temp < x_max)  
  hot <- filter(dat, temp > x_max)  
  # if(sum(cold$dr >=0) && sum(hot$dr >=0)){
  #     print("Complete")
  #   } else {(print("Incomplete"))}
  result = nrow(cold[!is.na(cold$dr),]) && nrow(hot[!is.na(hot$dr),])
  if(result){
    print("Complete")
  } else {
    print("Incomplete")
  }
 } else{
   print("Less than 4 data points")
 }
  
  
}


```


```{r}
# Apply is_complete() to all sets
SetAssessment <- Ana %>% 
  group_by(set) %>% 
  nest() %>% 
  mutate(curve = map(data,is_complete)) %>% 
  select(set, curve) %>% 
  unnest() 

```

From a total of `r length(unique(Ana$set))`, only  `r nrow(filter(SetAssessment, curve == "Complete"))` had a complete curve for development rate.
```{r}
# Select sets of life stages of interest: egg, larva, pupa, egg to emergence
complete_sets<- SetAssessment %>% 
  filter(curve == "Complete") 
list_complete <- (unique(complete_sets$set))
life_stages <- c("egg", "larva", "pupa", "eggtoemergence")
Ana_dr <- Ana %>% 
  filter(set %in% list_complete) %>% 
  filter(lifestage %in% life_stages)
egg_dr <- Ana_dr %>%
  filter(lifestage == "egg")
larva_dr <- Ana_dr %>%
  filter(lifestage == "larva")
pupa_dr <- Ana_dr %>%
  filter(lifestage == "pupa")
eggtoemergence_dr <- Ana_dr %>%
  filter(lifestage == "eggtoemergence")


```
There are `r length(unique(Ana_dr$set))` sets of the relevant lifestages (`r length(unique(Ana_dr$sp))`species). Of those, `r length(unique(egg_dr$set))` correspond to egg (N = `r length(unique(egg_dr$sp))` species), `r length(unique(larva_dr$set))` to larva (N = `r length(unique(larva_dr$sp))` species), `r length(unique(pupa_dr$set))`to pupa (N = `r length(unique(pupa_dr$sp))` species) and `r length(unique(eggtoemergence_dr$set))` to eggtoadult (N = `r length(unique(eggtoemergence_dr$sp))`)

3. Obtain predicted dr in the range from 0 to 40C using linear interpolation. 

```{r}
#create curves: 1- Make interpolation function:
interpolate <- function(dat) {
  out <- seq(from = 0, to = 40, by = 0.1)
  as.data.frame(approx(x = dat$temp, y = dat$dr, xout = out, method = "linear", rule = 1))
  
}

Predicted_Ana_dr <-  Ana_dr %>% 
  group_by(set) %>% 
  nest() %>% 
  mutate(predicted = map(data,interpolate)) %>% 
  select(set, predicted) %>% 
  unnest(cols = predicted)
names(Predicted_Ana_dr) <- c("set", "temp", "dr")
```



4. Calculate Ropt (rate at Topt) and minTopt, maxTopt
```{r}
# function to get optimum

get_Dopt <- function(dat){
  dat <- dat[!is.na(dat$dr) & !is.na(dat$temp),] # Remove treatments with no dr data
   y_max <- max(dat$dr, na.rm = T) # get maximum value for dr
  x_max_list <- dat[dat$dr == y_max, "temp"][[1]]# get temperature that maximizes dr   
  if(length(x_max_list) > 1){
    Dopt <- tibble(DTopt = x_max_list,
                   Dropt = y_max, 
                   Opt = "optima")
  } else{
    Dopt <- tibble(DTopt = x_max_list,
                   Dropt = y_max, 
                   Opt = "optimum")
  }
} 


# apply function to all sets
Dopts <- Predicted_Ana_dr %>% 
  group_by(set) %>% 
  nest() %>% 
  mutate(Dopt = map(data,get_Dopt)) %>% 
  select(set, Dopt)

# get a table with only one optimum temperature
singles <- Dopts %>% 
  unnest(cols = c(Dopt)) %>% 
  filter(Opt == "optimum")


# get a table with sets with multiple optima
multiple <- Dopts %>% 
  unnest(cols = c(Dopt)) %>% 
  filter(Opt == "optima")

# obtain minimum and maximum Dopt
```

There were `r length(unique(singles$set))` sets with a single optimum temperature and `r length(unique(multiple$set))` sets for which several temperatures allowed for development at optimum rates.


```{r}
# Function to create a table with : set, Dropt, maxTopt, minTopt from sets with multiple optima
get_2_optima <- function(dat){
  dr <- max(dat$Dropt)
  maxTDopt <- max(dat$DTopt, na.rm = T)
  minTDopt <- min(dat$DTopt, na.rm = T)
  outpu <- tibble(dr = dr, 
                  maxTDopt = maxTDopt,
                  minTDopt = minTDopt)
}


```


```{r}
#Apply get_2_optima() to sets with multiple optimum temperatures
two_optima_table <- multiple %>% 
  group_by(set) %>% 
  nest() %>% 
  mutate(Opt = map(data,get_2_optima)) %>% 
  select(set, Opt) %>% 
  unnest( cols = c(Opt))
```

```{r}
# minTopt (Topt for singles, minTopt for multiple)
# 1- Get values from "singles" table:
min_Topt_table1 <- singles %>% 
  mutate(minTDopt = DTopt) %>% # minTDopt = DTopt in sets with a single optimum
  select(set, Dropt, minTDopt) 

min_Topt_table2 <- two_optima_table %>% 
   mutate(Dropt = dr) %>%  # so columns have the same name in both tables
  select(set, Dropt, minTDopt)  

min_Topt_table3 <- rbind(min_Topt_table1, min_Topt_table2)
# Add columns for lifestage, lat, lon, population, sp and family for analyses

add_info <- Ana_dr %>% 
  select(set, sp, family, lifestage, lat, lon, locality, quality) %>% 
  distinct()

min_Topt_table <- inner_join(min_Topt_table3, add_info, by = "set")

```

```{r}
# maxTopt (Topt for singles, maxTopt for multiple)
# 1- Get values from "singles" table:
max_Topt_table1 <- singles %>% 
  mutate(maxTDopt = DTopt) %>% # minTDopt = DTopt in sets with a single optimum
  select(set, Dropt, maxTDopt) 

max_Topt_table2 <- two_optima_table %>% 
   mutate(Dropt = dr) %>%  # so columns have the same name in both tables
  select(set, Dropt, maxTDopt)  

max_Topt_table3 <- rbind(max_Topt_table1, max_Topt_table2)
max_Topt_table <- inner_join(max_Topt_table3, add_info, by = "set")

```

5. Calculate interval (min 50% dr, max 50% dr, length)

########## FIX THIS ############
Add an if statement for cases in which predicted values are larger than 50% efficiency. (not really bounded sets)
```{r}
# Returns values
get_interval <- function(dat){
  y_max <- max(dat$dr, na.rm = T) # get maximum value for dr
  x_max <- dat[dat$dr == y_max, "temp"][[1]]# get temperature that maximizes dr
  cold <- filter(dat, temp < x_max)  
  hot <- filter(dat, temp > x_max)  
  limit <- y_max/2
  if (min(cold$dr) > limit){
    print("cold incomplete")
    y_mincold <- NA
    x_min_cold <- NA
  } else{
    y_mincold <- min(filter(cold, dr <= y_max/2)[["dr"]])
    x_min_cold <- min(filter(cold, dr <= y_max/2)[["temp"]])
  }
  
  if(min(hot$dr) > limit){
    print("heat incomplete")
    y_minhot <- NA
    x_min_hot <- NA 
    
  } else {
    y_minhot <- min(filter(hot, dr <= y_max/2)[["dr"]])
    x_min_hot <- min(filter(hot, dr <= y_max/2)[["temp"]])
  }
  

  output <- tibble(Imin = x_min_cold, 
                   Imax = x_min_hot, 
                   Ilength = Imax - Imin)
  
  
}

set_w <- filter(Ana_dr, set == 3)

try <- get_interval(set_w)
ggplot(set_w, aes(x = temp, y = dr))+
  geom_point()

# apply function to all sets
Interval <- Predicted_Ana_dr %>% 
  group_by(set) %>% 
  nest() %>% 
  mutate(interval = map(data,get_interval)) %>% 
  select(set, interval) %>% 
  unnest(cols = interval)

ggplot(Interval, aes(x = Imin, y = Ilength))+
  geom_point()
```


```{r}
# Apply get interval to everything

```


6. Plot

```{r}
ggplot(max_Topt_table, aes(x = lifestage, y = maxTDopt, col = family))+
  geom_jitter()

ggplot(min_Topt_table, aes(x = lifestage, y = minTDopt, col = family, label = set))+
  geom_jitter()+
  geom_text()

ggplot(filter(Ana_dr, set == 586), aes(x = temp, y = dr))+
  geom_point()
```

7. Perform analyses