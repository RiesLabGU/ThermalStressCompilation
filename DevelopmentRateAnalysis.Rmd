---
title: "Development rate"
output: html_notebook
---
## Steps
1. Import data
2. Select sets with at least 4 data points and a complete curve (low, peak, high) for egg, larva, pupa, eggtoadult.
3. Obtain predicted dr in the range from 0 to 40 C using linear interpolation
4. Calculate Topt & Ropt (rate at Topt)
5. Calculate interval (min, max, length)
6. Plot
7. Perform analyses

```{r}
# load packages
library(tidyverse)
library(readxl)
library(cowplot)
```

 Import data
```{r}
# Mariana's desktop
Data <- read_xlsx("/Users/marianaabarcazama/Desktop/Projects/ThermalPerformance/PhysiologyDatabaseVersion5.xlsx", 
                  sheet = "WorkingTable", na = c("NA", ""))
```

```{r}
# Mariana's laptop
Data <- read_xlsx("/Users/mar/Desktop/Projects/ThermalPerformance/PhysiologyDatabaseVersion5.xlsx", 
                  sheet = "WorkingTable", na = c("NA", "")) 

```


```{r}
# Discard parasitoids and change character to factor 
unique(Data$status)
Ana <- Data[Data$status != "parasitoid",]
rm(Data)

# convert character to factor
Ana <- Ana %>%
  mutate_if(is.character, factor)
```

# 2. Select sets 
To be included in development rate analyses, sets should have at least 4 temperature treatments reporting development time that form a complete curve (low 50%, peak, high 50%) for egg, larva, pupa or eggtoadult.


```{r}
# Function to determine whether a set is:
# "Complete" (has low, peak and high values)
# "Incomplete" (only low and peak)
# "No data" (no development rate data available)
Ana$set2 <- Ana$set
is_complete <- function(dat){
  dat <- dat[!is.na(dat$dr) & !is.na(dat$temp),] # Remove treatments with no dr data
 if(nrow(dat) > 3 ){
  
   y_max <- max(dat$dr, na.rm = T) # get maximum value for dr
  x_max <- dat[dat$dr == y_max, "temp"][[1]][1]# get temperature that maximizes dr 
  
  species <- unique(dat$sp)
  lifestage <- unique(dat$lifestage)
  seti <- unique(dat$set2)
  print(paste("set:",seti))
  print(species)
  print(lifestage)
  print(x_max)
  print(y_max)
  cold <- filter(dat, temp < x_max)  
  hot <- filter(dat, temp > x_max)  
  # if(sum(cold$dr >=0) && sum(hot$dr >=0)){
  #     print("Complete")
  #   } else {(print("Incomplete"))}
  result = nrow(cold[!is.na(cold$dr),]) && nrow(hot[!is.na(hot$dr),])
  if(result){
    print("Complete")
  } else {
    print("Incomplete")
  }
 } else{
   print("Less than 4 data points")
 }
  
  
}


```


```{r}
# Apply is_complete() to all sets
SetAssessment <- Ana %>% 
  group_by(set) %>% 
  nest() %>% 
  mutate(curve = map(data,is_complete)) %>% 
  select(set, curve) %>% 
  unnest() 

```

From a total of `r length(unique(Ana$set))`, only  `r nrow(filter(SetAssessment, curve == "Complete"))` had a complete curve for development rate.
```{r}
# Select sets of life stages of interest: egg, larva, pupa, egg to emergence
complete_sets<- SetAssessment %>% 
  filter(curve == "Complete") 
list_complete <- (unique(complete_sets$set))
life_stages <- c("egg", "larva", "pupa", "eggtoemergence")
Ana_dr <- Ana %>% 
  filter(set %in% list_complete) %>% 
  filter(lifestage %in% life_stages)
egg_dr <- Ana_dr %>%
  filter(lifestage == "egg")
larva_dr <- Ana_dr %>%
  filter(lifestage == "larva")
pupa_dr <- Ana_dr %>%
  filter(lifestage == "pupa")
eggtoemergence_dr <- Ana_dr %>%
  filter(lifestage == "eggtoemergence")


```
There are `r length(unique(Ana_dr$set))` sets of the relevant lifestages (`r length(unique(Ana_dr$sp))`species). Of those, `r length(unique(egg_dr$set))` correspond to egg (N = `r length(unique(egg_dr$sp))` species), `r length(unique(larva_dr$set))` to larva (N = `r length(unique(larva_dr$sp))` species), `r length(unique(pupa_dr$set))`to pupa (N = `r length(unique(pupa_dr$sp))` species) and `r length(unique(eggtoemergence_dr$set))` to eggtoadult (N = `r length(unique(eggtoemergence_dr$sp))`)

3. Obtain predicted dr in the range from 0 to 40C using linear interpolation. 

```{r}
#create curves: 1- Make interpolation function:
interpolate <- function(dat) {
  out <- seq(from = 0, to = 40, by = 0.1)
  as.data.frame(approx(x = dat$temp, y = dat$dr, xout = out, method = "linear", rule = 1))
  
}

Predicted_Ana_dr <-  Ana_dr %>% 
  group_by(set) %>% 
  nest() %>% 
  mutate(predicted = map(data,interpolate)) %>% 
  select(set, predicted) %>% 
  unnest(cols = predicted)
names(Predicted_Ana_dr) <- c("set", "temp", "dr")
```



4. Calculate Topt & Ropt (rate at Topt)
```{r}
# function to get optimum

get_Dopt <- function(dat){
  dat <- dat[!is.na(dat$dr) & !is.na(dat$temp),] # Remove treatments with no dr data
   y_max <- max(dat$dr, na.rm = T) # get maximum value for dr
  x_max_list <- dat[dat$dr == y_max, "temp"][[1]]# get temperature that maximizes dr   
  if(length(x_max_list) > 1){
    Dopt <- tibble(DTopt = x_max_list,
                   Dropt = y_max, 
                   Opt = "optima")
  } else{
    Dopt <- tibble(DTopt = x_max_list,
                   Dropt = y_max, 
                   Opt = "optimum")
  }
} 


# apply function to all sets
Dopts <- Predicted_Ana_dr %>% 
  group_by(set) %>% 
  nest() %>% 
  mutate(Dopt = map(data,get_Dopt)) %>% 
  select(set, Dopt)
# get a table with only one optimum temperature
singles <- Dopts %>% 
  unnest(cols = c(Dopt)) %>% 
  filter(Opt == "optimum")


# get a table with sets with multiple optima
multiple <- Dopts %>% 
  unnest(cols = c(Dopt)) %>% 
  filter(Opt == "optima")

# obtain minimum and maximum Dopt
```

There were ` r length(unique(singles$set))` sets with a single optimum temperature and ` r length(unique(multiple$set))` sets for which several temperatures allowed for development at optimum rates.


```{r}
# Function to create a table with : set, Dropt, maxTopt, minTopt from sets with multiple optima
get_2_optima <- function(dat){
  dr <- max(dat$Dropt)
  maxTDopt <- max(dat$DTopt, na.rm = T)
  minTDopt <- min(dat$DTopt, na.rm = T)
  outpu <- tibble(dr = dr, 
                  maxTDopt = maxTDopt,
                  minTDopt = minTDopt)
}


```


```{r}
#Apply get_2_optima() to sets with multiple optimum temperatures
two_optima_table <- multiple %>% 
  group_by(set) %>% 
  nest() %>% 
  mutate(Opt = map(data,get_2_optima)) %>% 
  select(set, Opt) %>% 
  unnest( cols = c(Opt))
```


5. Calculate interval (min, max, length)



```{r}
# Returns values
get_shape <- function(dat){
y_max <- max(dat$dr, na.rm = T) # get maximum value for dr
x_max <- dat[dat$dr == y_max, "temp"][[1]]# get temperature that maximizes dr
cold <- filter(dat, temp < x_max)  
hot <- filter(dat, temp > x_max)  
c_lethal <- tail(filter(cold, dr == 0)[["temp"]],1)
h_lethal <- head(filter(hot, dr == 0)[["temp"]],1)
mincold <- filter(cold, dr > 0)
minhot <- filter(hot, dr > 0)
y_min_cold <- min(mincold$dr)
x_min_cold <- mincold[mincold$dr == y_min_cold,"temp"][[1]]
y_min_hot <- min(minhot$dr)
x_min_hot <- minhot[minhot$dr == y_min_hot, "temp"][[1]]

output <- tibble(set = rep(unique(dat$set), 5),
                 lifestage =rep(unique(dat$lifestage),5),
                 variable = c("Dopt","minCold", "minHot", 
                             "lethalCold","lethalHot"),
                 temp = c(x_max, x_min_cold, x_min_hot, 
                          c_lethal, h_lethal),
                 dr = c(y_max, y_min_cold, y_min_hot,
                        NA,NA))
output

}

```

6. Plot


7. Perform analyses