---
title: "Combined Dataset Manipulation"
output: html_notebook
---

## Introduction

This script is working with the subsetted dataset that contains only those sets with both development rate and survival information. From this dataset, we will be able to compare how thermal optima differ for survival and development rate metrics, as well as directly investigate portions of fitness at different temperatures. 

## Roadmap

1. Load in the data 
2. Do linear interpolation to create "best-fit curves"
3. Extract values from interpolated curves
4. Copy Mariana's functions to calculate metrics
5. Apply to all sets
6. Graph metrics for all sets

## 1. Load in the Data

```{r}
library(tidyverse)
library(readxl)
library(cowplot)
```

```{r}
#Anna's Laptop
Data <- read_xlsx("~/Desktop/PhysiologyDatabaseVersion5.xlsx", sheet = "T3", na = c("NA", ""))
SetQuality <- read_csv("~/Desktop/GitHub/ThermalStressCompilation/SetCharacterization.csv")
```

### Adapt dataset to just contain sets with development rate and survival data

```{r}
Ana <- Data[Data$status != "parasitoid",]
rm(Data)

# convert character to factor
Ana <- Ana %>%
  mutate_if(is.character, factor)
```

Calculate development rate:

```{r}
fast <- filter(Ana, dt < 1)
Ana <- Ana %>% 
  mutate(dt = ifelse(dt < 1, ceiling(dt),dt))
  

sets <- unique(Ana$set) 
rates <- tribble(~set, ~temp, ~dr)
rates2 <- tribble(~set, ~temp, ~dr)
output.table <- tibble()

for(i in seq_along(sets)) {
  
  # make a table per set and determine whether it includes dt data
  seti <- sets[i]
  table <- filter(Ana, set == seti)
  suma <- sum(table$dt, na.rm = T)
  
  # if there is dt data
  if (suma > 0){ 
    
    clement <- filter(table, dt > 0) [["temp"]] # temperatures that allow for development
    hotlim <- max(clement, na.rm = T) # max temp that permits development
    coldlim <- min(clement, na.rm = T) # min temp that permits development
    tempes <- unique(table$temp) # each temperature included in set i
    
    # evaluate each temperature of a set
    for(ii in 1:length(unique(tempes))){
      
      tempii <- tempes[ii]
      
      # if it is lower than coldlim, dr should be zero
      if (table$temp[ii] < coldlim){
        dr <- 0
      output.row <- cbind(set = seti, temp = tempii, dr = dr)
      
      # if it is higher than hotlim, dr should be zero  
      } else if (table$temp[ii] > hotlim) {
        
        dr <- 0
      output.row <- cbind(set = seti, temp = tempii, dr = dr)
      
      # in all other cases, it should be 1/dt
      } else{
        dr <- 1/table$dt[ii]
        output.row <- cbind(set = seti, temp = tempii, dr = dr)
      }
      
      output.table <- rbind(output.table, output.row)
    }
    
    # print stuff to make sure loop is working
    #cat(seti, " ")
    
    
  # if there is no development time in that set, dr should be zero
    } else {
    #cat("set: ", seti, "has no dt \n")
  }
  
}

rates <- output.table

Ana_rates <- left_join(Ana, rates, by = c("set","temp"))

rm(fast, output.row, output.table, rates, rates2, table)
rm(clement, coldlim, dr, hotlim, i, ii, seti, sets, suma, tempes, tempii)

```


### Get just sets with dev rate and survival:

```{r}
interval_sets <- Ana_rates %>% 
  group_by(set) %>% 
   
  mutate(dr_sum = sum(dr), 
         n_temps = length(unique(temp)), 
         validcount = sum(!is.na(dt)), 
         validcount_s = sum(!is.na(survival))) %>% 
  filter(n_temps > 3, dr_sum > 0, validcount > 3, validcount_s > 3)

interval_set_list <- unique(interval_sets$set) 

interval <- Ana_rates %>% filter(set %in% interval_set_list)

main_stages <- Ana_rates %>% 
  filter(lifestage == "egg"|lifestage == "larva"|lifestage == "pupa")
main_stages_list <- unique(main_stages$lifestage)
inter <- interval %>% filter(lifestage %in% main_stages_list) 
inter$lifestage <- factor(inter$lifestage)

```

Get list of complete sets:

```{r}
d_complete_sets <- SetQuality %>% # to get a list of complete sets for dt
  filter(just.rise == FALSE) %>% 
  select(set) %>% 
  distinct()

s_complete_sets <- SetQuality %>% # to get a list of complete sets for survival
  filter(just.rise1 == FALSE) %>% 
  select(set) %>% 
  distinct()
```


## 2. Do linear interpolation

### Calculate scaled development rate

Create a function to scale development rate as a percentage of the maximum:

```{r}
scale.dr <- function(table){
  maxdr <- max(table$dr, na.rm = T)
  table$s_dr <- (table$dr/maxdr)
  table
}
```

Apply that function to inter:

```{r}
inter <- inter %>% 
  group_by(set) %>% 
  nest() %>% 
  mutate(s_dr = map(data, scale.dr)) %>% 
  unnest(cols = s_dr) %>% 
  select(-data)
```

### Choose a dummy set to test with (set 3)

```{r}
set_3 <- filter(inter, set == 3)
```

### Run linear interpolations on survival and scaled development rate

Survival:

```{r}
surv_3 <- approx(x = set_3$temp, y = set_3$survival, xout = set_3$temp, method = "linear", rule = 1)

surv_3 <- as.data.frame(surv_3)

ggplot(data = surv_3, aes(x = x, y = y)) + 
  geom_point() + 
  geom_line()

surv_3_2 <- approx(x = set_3$temp, y = set_3$survival, method = "linear", rule = 1, n = 1000)
surv_3_2 <- as.data.frame(surv_3_2)

ggplot(data = set_3, aes(x = temp, y = survival)) + 
  geom_point() + 
  geom_line(data = surv_3_2, aes(x = x, y = y))


#surv_3_fun <- approxfun(x = set_3$temp, y = set_3$survival, method = "linear", rule = 1)

#surv_3_fun

```

## 3. Extract values from interpolated curves

### Find midpoint of survival

(Survival max - survival min)/2 + survival min = survival midpoint 

```{r}
max_3 <- max(set_3$survival)
min_3 <- min(set_3$survival)
mid_3 <- ((max_3 - min_3) / 2) + min_3

```

### Find all values of temp where survival >= midpoint

```{r}
temps <- vector(mode = "list", length = 0)

surv_int <- for(i in 1:length(surv_3_2$x)){
  if (surv_3_2[i, 2] >= mid_3){
      temps<- c(temps, surv_3_2[i, 1])
  } 

}

#Only loops once and deletes the first value
```

Let's try another way:

```{r}
#library(magicfor)


#magic_for()

#for(i in 1:length(surv_3_2)){
#  if (surv_3_2[i, 2] >= mid_3){
#    int <- surv_3_2[i, 1]  
# } 
# put(int)
#}


#temps_2 <- magic_result_as_dataframe()

#Only loops twice
```

Modified a printed loop to save the output: 

```{r}
temps_3 <- data.frame(temp = character())

for(i in 1:length(surv_3_2$x)){
  if (surv_3_2[i, 2] >= mid_3){
    temps_3 <- rbind(temps_3, surv_3_2[i, 1])  
  } 

}
```



### Extract endpoints on curve

```{r}
min_temp_3 <- min(temps_3)
max_temp_3 <- max(temps_3)
```


## Write a function to do the above:

List of set values in inter:

```{r}
setvals <- unique(inter$set)
```


```{r}
midpoint_surv <- function(table){
  for (i in setvals){
    set <- filter (table, set == i)
    max <- max(set$survival)
    min <- min(set$survival)
    mid <- ((max - min)/2) + min
    
    
  } 
  
  
}

##Stopped halfway through to figure out what I'm doing above
```


## 4. Copy Mariana's functions 

## 5. Apply to all sets

0. Make an empty dataframe with set, minTemp, maxTemp, survival midpoint 
1. Find midpoint
2. Apply linear interpolation
3. Find all interpolated values where temp >= midpoint
4. Find min and max of that range
5. Print a dataframe row with set, minTemp, maxTemp, survival midpoint

```{r}
setvals <- unique(inter$set)
surv_range_vals <- data.frame(set = integer(), minTemp = integer(), maxTemp = integer(), survMid = integer())

surv_range <- function(table){
  for (i in setvals){
    set <- filter (table, set == i)
    max <- max(set$survival)
    min <- min(set$survival)
    mid <- ((max - min)/2) + min
    
    interpol <- approx(x = set$temp, y = set$survival, method = "linear", rule = 1, n = 1000)
    interpol <- as.data.frame(interpol)
    
    interpol_temps <- data.frame(temp = character())

    for (j in 1:length(interpol$x)){
      if (interpol[j, 2] >= mid){
      interpol_temps <- rbind(interpol_temps, interpol[j, 1]) 
     }
    } 
    
    min_interpol <- min(interpol_temps)
    max_interpol <- max(interpol_temps)

    new_row <- c(i, min_interpol, max_interpol, mid)
    surv_range_vals <- rbind(surv_range_vals, new_row)
    
    
}  
}

surv_range(inter)
```

## 6. Graph metrics for all sets


# Jess Helping 

Make basic dataset to test it

```{r}
test <- read.csv("~/Desktop/test.csv", header = TRUE)
```


```{r}
surv_3_2[2, 1]

max <- max(test$survival)
min <- min(test$survival)
mid <- ((max - min)/2) + min
message(mid)
for(i in 1:(length(test$temp)-1)){
  print(i)
  tempCol = 1
  survivalCol = 2
  x1 = test[i, tempCol]
  x2 = test[i + 1, tempCol]
  y1 = test[i, survivalCol]
  y2 = test[i + 1, survivalCol]
  slope = (y2 -y1)/(x2-x1)
  n = y1 - slope * x1
  message("x1: ", x1, " y1: ", y1)
  message("x2: ", x2, " y2: ", y2)
  message("slope: ", slope, " n:", n)
  
  xAvg = (mid - n)/slope
  if( xAvg >= x1 && xAvg<= x2){
    message("xAvg is between x1 and x2: ", xAvg)
  }
  
  
}

```

```{r}
surv_range <- function(table){
  for (i in setvals){
    set <- filter (table, set == i)
    max <- max(set$survival)
    min <- min(set$survival)
    mid <- ((max - min)/2) + min
    
    interpol <- approx(x = set$temp, y = set$survival, method = "linear", rule = 1, n = 1000)
    interpol <- as.data.frame(interpol)
    
    interpol_temps <- data.frame(temp = character())

    for (j in 1:length(interpol$x)){
      if (interpol[j, 2] >= mid){
      interpol_temps <- rbind(interpol_temps, interpol[j, 1]) 
     }
    } 
    
    min_interpol <- min(interpol_temps)
    max_interpol <- max(interpol_temps)

    new_row <- c(i, min_interpol, max_interpol, mid)
    surv_range_vals <- rbind(surv_range_vals, new_row)
    
    
}  
}

```



